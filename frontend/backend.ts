/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * backend
 * OpenAPI spec version: 1.0.0
 */
import * as axios from 'axios';
import type {
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';


// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
T,
>() => T extends Y ? 1 : 2
? A
: B;

type WritableKeys<T> = {
[P in keyof T]-?: IfEquals<
  { [Q in P]: T[P] },
  { -readonly [Q in P]: T[P] },
  P
>;
}[keyof T];

type UnionToIntersection<U> =
  (U extends any ? (k: U)=>void : never) extends ((k: infer I)=>void) ? I : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>] ? {
  [P in keyof Writable<T>]: T[P] extends object
    ? NonReadonly<NonNullable<T[P]>>
    : T[P];
} : DistributeReadOnlyOverUnions<T>;

export interface AppConfig {
  /** A URL to the JSON Schema for this object. */
  readonly $schema?: string;
  AppMode: AppMode;
  Github: Github;
  LocalFile: LocalFile;
}

export interface AppConfigUpdateOutputBody {
  /** A URL to the JSON Schema for this object. */
  readonly $schema?: string;
  /** Update status message */
  message: string;
}

export interface AppMode { [key: string]: unknown }

export interface Document {
  /** File name */
  name: string;
  path: string;
}

export interface ErrorDetail {
  /** Where the error occurred, e.g. 'body.items[3].tags' or 'path.thing-id' */
  location?: string;
  /** Error message text */
  message?: string;
  /** The value at the given location */
  value?: unknown;
}

/**
 * Optional list of individual error details
 */
export type ErrorModelErrors = ErrorDetail[] | null;

export interface ErrorModel {
  /** A URL to the JSON Schema for this object. */
  readonly $schema?: string;
  /** A human-readable explanation specific to this occurrence of the problem. */
  detail?: string;
  /** Optional list of individual error details */
  errors?: ErrorModelErrors;
  /** A URI reference that identifies the specific occurrence of the problem. */
  instance?: string;
  /** HTTP status code */
  status?: number;
  /** A short, human-readable summary of the problem type. This value should not change between occurrences of the error. */
  title?: string;
  /** A URI reference to human-readable documentation for the error. */
  type?: string;
}

export interface FileInfo {
  /** Whether this is a directory */
  is_dir: boolean;
  /** File or directory name */
  name: string;
}

/**
 * Files and directories in the path
 */
export type GetDirectoryOutputBodyItems = FileInfo[] | null;

export interface GetDirectoryOutputBody {
  /** A URL to the JSON Schema for this object. */
  readonly $schema?: string;
  /** Files and directories in the path */
  items: GetDirectoryOutputBodyItems;
  /** Searched directory path */
  path: string;
}

export interface GetDocumentContentOutputBody {
  /** A URL to the JSON Schema for this object. */
  readonly $schema?: string;
  /** Document content */
  content: string;
  /** Document path */
  path: string;
}

/**
 * List of documents found in the directory
 */
export type GetDocumentsOutputBodyDocuments = Document[] | null;

export interface GetDocumentsOutputBody {
  /** A URL to the JSON Schema for this object. */
  readonly $schema?: string;
  /** List of documents found in the directory */
  documents: GetDocumentsOutputBodyDocuments;
}

export type GithubIgnoreRepos = string[] | null;

export interface Github {
  AccessToken: string;
  IgnoreRepos: GithubIgnoreRepos;
}

export type LocalFileDirectories = string[] | null;

export interface LocalFile {
  Directories: LocalFileDirectories;
}

export interface UpdateDocumentContentInputBody {
  /** A URL to the JSON Schema for this object. */
  readonly $schema?: string;
  /** New content for the document */
  content: string;
}

export interface UpdateDocumentContentOutputBody {
  /** A URL to the JSON Schema for this object. */
  readonly $schema?: string;
  /** Success or error message */
  message: string;
  /** Document path */
  path: string;
  /** Whether the update was successful */
  success: boolean;
}

export type GetDirectoryParams = {
/**
 * Absolute path to directory
 */
path?: string;
/**
 * Kind of directory source (e.g., 'local', 'github')
 */
kind?: string;
};

export type GetDocumentContentParams = {
/**
 * Absolute path to the document
 */
path?: string;
/**
 * Kind of document source (e.g., 'local', 'github')
 */
kind?: string;
};

export type PutDocumentContentParams = {
/**
 * Absolute path to the document
 */
path?: string;
/**
 * Kind of document source (e.g., 'local', 'github')
 */
kind?: string;
};

export type GetDocumentsParams = {
/**
 * Absolute path to directory
 */
path?: string;
/**
 * Kind of document source (e.g., 'local', 'github')
 */
kind?: string;
};

/**
 * @summary List
 */
export const list = <TData = AxiosResponse<string>>(
     options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.default.get(
      `/`,{
        responseType: 'text',
    ...options,}
    );
  }

/**
 * @summary Put appconfig
 */
export const putAppconfig = <TData = AxiosResponse<AppConfigUpdateOutputBody>>(
    appConfig: NonReadonly<AppConfig>, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.default.put(
      `/appconfig`,
      appConfig,options
    );
  }

/**
 * @summary Get directory
 */
export const getDirectory = <TData = AxiosResponse<GetDirectoryOutputBody>>(
    params?: GetDirectoryParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.default.get(
      `/directory`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Get document content
 */
export const getDocumentContent = <TData = AxiosResponse<GetDocumentContentOutputBody>>(
    params?: GetDocumentContentParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.default.get(
      `/document/content`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Put document content
 */
export const putDocumentContent = <TData = AxiosResponse<UpdateDocumentContentOutputBody>>(
    updateDocumentContentInputBody: NonReadonly<UpdateDocumentContentInputBody>,
    params?: PutDocumentContentParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.default.put(
      `/document/content`,
      updateDocumentContentInputBody,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

/**
 * @summary Get documents
 */
export const getDocuments = <TData = AxiosResponse<GetDocumentsOutputBody>>(
    params?: GetDocumentsParams, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.default.get(
      `/documents`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }

export type ListResult = AxiosResponse<string>
export type PutAppconfigResult = AxiosResponse<AppConfigUpdateOutputBody>
export type GetDirectoryResult = AxiosResponse<GetDirectoryOutputBody>
export type GetDocumentContentResult = AxiosResponse<GetDocumentContentOutputBody>
export type PutDocumentContentResult = AxiosResponse<UpdateDocumentContentOutputBody>
export type GetDocumentsResult = AxiosResponse<GetDocumentsOutputBody>
