/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * backend
 * OpenAPI spec version: 1.0.0
 */
import * as axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

import useSwr from 'swr';
import type {
  Key,
  SWRConfiguration
} from 'swr';

import useSWRMutation from 'swr/mutation';
import type {
  SWRMutationConfiguration
} from 'swr/mutation';

import type {
  AppConfig,
  AppConfigUpdateOutputBody,
  ErrorModel,
  GetDirectoryOutputBody,
  GetDirectoryParams,
  GetDocumentContentOutputBody,
  GetDocumentContentParams,
  GetDocumentsOutputBody,
  GetDocumentsParams,
  PutDocumentContentParams,
  UpdateDocumentContentInputBody,
  UpdateDocumentContentOutputBody
} from './model';


// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
T,
>() => T extends Y ? 1 : 2
? A
: B;

type WritableKeys<T> = {
[P in keyof T]-?: IfEquals<
  { [Q in P]: T[P] },
  { -readonly [Q in P]: T[P] },
  P
>;
}[keyof T];

type UnionToIntersection<U> =
  (U extends any ? (k: U)=>void : never) extends ((k: infer I)=>void) ? I : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>] ? {
  [P in keyof Writable<T>]: T[P] extends object
    ? NonReadonly<NonNullable<T[P]>>
    : T[P];
} : DistributeReadOnlyOverUnions<T>;



  
  
  
/**
 * @summary List
 */
export const list = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    return axios.default.get(
      `/`,{
        responseType: 'text',
    ...options,}
    );
  }



export const getListKey = () => [`/`] as const;

export type ListQueryResult = NonNullable<Awaited<ReturnType<typeof list>>>
export type ListQueryError = AxiosError<ErrorModel>

/**
 * @summary List
 */
export const useList = <TError = AxiosError<ErrorModel>>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof list>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getListKey() : null);
  const swrFn = () => list(axiosOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Get appconfig
 */
export const getAppconfig = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AppConfig>> => {
    return axios.default.get(
      `/appconfig`,options
    );
  }



export const getGetAppconfigKey = () => [`/appconfig`] as const;

export type GetAppconfigQueryResult = NonNullable<Awaited<ReturnType<typeof getAppconfig>>>
export type GetAppconfigQueryError = AxiosError<ErrorModel>

/**
 * @summary Get appconfig
 */
export const useGetAppconfig = <TError = AxiosError<ErrorModel>>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getAppconfig>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetAppconfigKey() : null);
  const swrFn = () => getAppconfig(axiosOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Put appconfig
 */
export const putAppconfig = (
    appConfig: NonReadonly<AppConfig>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AppConfigUpdateOutputBody>> => {
    return axios.default.put(
      `/appconfig`,
      appConfig,options
    );
  }



export const getPutAppconfigMutationFetcher = ( options?: AxiosRequestConfig) => {
  return (_: Key, { arg }: { arg: NonReadonly<AppConfig> }): Promise<AxiosResponse<AppConfigUpdateOutputBody>> => {
    return putAppconfig(arg, options);
  }
}
export const getPutAppconfigMutationKey = () => [`/appconfig`] as const;

export type PutAppconfigMutationResult = NonNullable<Awaited<ReturnType<typeof putAppconfig>>>
export type PutAppconfigMutationError = AxiosError<ErrorModel>

/**
 * @summary Put appconfig
 */
export const usePutAppconfig = <TError = AxiosError<ErrorModel>>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof putAppconfig>>, TError, Key, NonReadonly<AppConfig>, Awaited<ReturnType<typeof putAppconfig>>> & { swrKey?: string }, axios?: AxiosRequestConfig}
) => {

  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getPutAppconfigMutationKey();
  const swrFn = getPutAppconfigMutationFetcher(axiosOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Get directory
 */
export const getDirectory = (
    params?: GetDirectoryParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetDirectoryOutputBody>> => {
    return axios.default.get(
      `/directory`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getGetDirectoryKey = (params?: GetDirectoryParams,) => [`/directory`, ...(params ? [params]: [])] as const;

export type GetDirectoryQueryResult = NonNullable<Awaited<ReturnType<typeof getDirectory>>>
export type GetDirectoryQueryError = AxiosError<ErrorModel>

/**
 * @summary Get directory
 */
export const useGetDirectory = <TError = AxiosError<ErrorModel>>(
  params?: GetDirectoryParams, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getDirectory>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetDirectoryKey(params) : null);
  const swrFn = () => getDirectory(params, axiosOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Get document content
 */
export const getDocumentContent = (
    params?: GetDocumentContentParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetDocumentContentOutputBody>> => {
    return axios.default.get(
      `/document/content`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getGetDocumentContentKey = (params?: GetDocumentContentParams,) => [`/document/content`, ...(params ? [params]: [])] as const;

export type GetDocumentContentQueryResult = NonNullable<Awaited<ReturnType<typeof getDocumentContent>>>
export type GetDocumentContentQueryError = AxiosError<ErrorModel>

/**
 * @summary Get document content
 */
export const useGetDocumentContent = <TError = AxiosError<ErrorModel>>(
  params?: GetDocumentContentParams, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getDocumentContent>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetDocumentContentKey(params) : null);
  const swrFn = () => getDocumentContent(params, axiosOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Put document content
 */
export const putDocumentContent = (
    updateDocumentContentInputBody: NonReadonly<UpdateDocumentContentInputBody>,
    params?: PutDocumentContentParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UpdateDocumentContentOutputBody>> => {
    return axios.default.put(
      `/document/content`,
      updateDocumentContentInputBody,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getPutDocumentContentMutationFetcher = (params?: PutDocumentContentParams, options?: AxiosRequestConfig) => {
  return (_: Key, { arg }: { arg: NonReadonly<UpdateDocumentContentInputBody> }): Promise<AxiosResponse<UpdateDocumentContentOutputBody>> => {
    return putDocumentContent(arg, params, options);
  }
}
export const getPutDocumentContentMutationKey = (params?: PutDocumentContentParams,) => [`/document/content`, ...(params ? [params]: [])] as const;

export type PutDocumentContentMutationResult = NonNullable<Awaited<ReturnType<typeof putDocumentContent>>>
export type PutDocumentContentMutationError = AxiosError<ErrorModel>

/**
 * @summary Put document content
 */
export const usePutDocumentContent = <TError = AxiosError<ErrorModel>>(
  params?: PutDocumentContentParams, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof putDocumentContent>>, TError, Key, NonReadonly<UpdateDocumentContentInputBody>, Awaited<ReturnType<typeof putDocumentContent>>> & { swrKey?: string }, axios?: AxiosRequestConfig}
) => {

  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getPutDocumentContentMutationKey(params);
  const swrFn = getPutDocumentContentMutationFetcher(params, axiosOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Get documents
 */
export const getDocuments = (
    params?: GetDocumentsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GetDocumentsOutputBody>> => {
    return axios.default.get(
      `/documents`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getGetDocumentsKey = (params?: GetDocumentsParams,) => [`/documents`, ...(params ? [params]: [])] as const;

export type GetDocumentsQueryResult = NonNullable<Awaited<ReturnType<typeof getDocuments>>>
export type GetDocumentsQueryError = AxiosError<ErrorModel>

/**
 * @summary Get documents
 */
export const useGetDocuments = <TError = AxiosError<ErrorModel>>(
  params?: GetDocumentsParams, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getDocuments>>, TError> & { swrKey?: Key, enabled?: boolean }, axios?: AxiosRequestConfig }
) => {
  const {swr: swrOptions, axios: axiosOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetDocumentsKey(params) : null);
  const swrFn = () => getDocuments(params, axiosOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

